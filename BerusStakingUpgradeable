// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";

contract BerusStakingUpgradeable is Initializable, OwnableUpgradeable, ERC20Upgradeable, UUPSUpgradeable {

    /**
     * UUPS 模式重写 _authorizeUpgrade 函数
     * _Authorizeupgrade must be overriden when use UUPS
     */
    function _authorizeUpgrade(address newImplementation) internal override onlyOwner() {}

    using SafeMathUpgradeable for uint256;

    event newInvestor(address investor, uint256 amount);
    event cancelInvested(address _address);
    event roundFinish();
    event modifyInitDays(uint256 initInvestDays, uint256 initLockDays);
    event modifyFees(uint256 investFee, uint256 rewardFee);
    event investOpen();
    event investClose();

    /**
     * 查询某地址下的质押额度
     * Invest of the address
     */
    mapping(address => uint256) private balances;

    /**
     * 开启/关闭质押（默认关闭）
     * Open/Close the invest (default closed)
     */
    bool private isInvestOpen;

    /**
     * 手续费
     * Invest fee
     */
    uint256 private investFee;

    /**
     * 回报率
     * Invest reward
     */
    uint256 private rewardFee;

    /**
     * 筹备默认天数
     * Default days for invest preparation
     */
    uint256 private initInvestDays;

    /**
     * 默认天数
     * Default days for invest
     */
    uint256 private initLockDays;

    /**
     * 质押筹备天数
     * Days for invest preparation
     */
    uint256 private investDays;

    /**
     * 质押天数
     * Days for invest
     */
    uint256 private lockDays;

    /**
     * 质押阶段
     * Stage of invest
     */
    bool private lockLevel;

    /**
     * 所有质押地址
     * All invest address
     */
    address[] private investHolders;


    /**
     * 质押总额度
     * Total balance of invest
     */
    uint256 private totalInvested;

    /**
     * 10 ** 18
     * 10 ** 18
     */
    uint256 constant Precision = 1 ether;

    function initialize(uint256 totalSupply, uint256 _investFee, uint256 _rewardFee, uint256 _investDays, uint256 _lockDays) external initializer {
        require(_investDays != 0, "Invest days can not be 0");
        require(_lockDays != 0, "Invest days can not be 0");
        require(_investDays < _lockDays, "Lock days must be later than invest days");
        /**
        * 回报额度应该大于本金
        * The amount of reward should be more than the principal
        */
        require((100 - _investFee) * (100 + _rewardFee) > 10000, "Invalid invest fee and reward fee");

        /**
        * Upgradeable Contract 需要主动调用继承的 init 函数
        * Upgradeable Contract need to actively call the inherited init function
        */
        __Ownable_init();
        __ERC20_init("Cerberus Berus Token", "BERUS");
        _mint(_msgSender(), totalSupply * Precision);
        isInvestOpen = false;
        investFee = _investFee;
        rewardFee = _rewardFee;
        initInvestDays = _investDays;
        initLockDays = _lockDays;
    }

    function getIsInvestOpen()  external view returns (bool) {
        return isInvestOpen;
    }

    function getInvestFee() external view returns (uint256) {
        return investFee;
    }

    function getRewardFee() external view returns (uint256) {
        return rewardFee;
    }

    function getInvestDays() external view returns (uint256) {
        return investDays;
    }

    function getLockDays() external view returns (uint256) {
        return lockDays;
    }

    function getInvestHolders() external view returns (address[] memory) {
        return investHolders;
    }

    function getTotalInvested() external view returns (uint256) {
        return totalInvested;
    }

    function getBalances(address _address) external view returns (uint256) {
        return balances[_address];
    }

    function getLeftTime() external view returns (uint256) {
        if(!isInvestOpen) return 0;
        if(!lockLevel) return investDays - block.timestamp;
        return lockDays - block.timestamp;
    }

    function openInvest() external onlyOwner() {
        require(isInvestOpen == false, "Invest already open");
        isInvestOpen = true;
        investDays = block.timestamp + initInvestDays * 1 days;
        lockDays = block.timestamp + initLockDays * 1 days;

        emit investOpen();
    }

    function closeInvest() external onlyOwner() {
        require(isInvestOpen == true, "Invest already cloes");
        isInvestOpen = false;
        /**
        * 若没有进入质押第二阶段，则返还所有质押额度
        * If the second stage of invest is not entered, all invest amounts shall be returned
        */
        require(block.timestamp < investDays, "Close invest too late");

        for(uint256 i ; i<investHolders.length ; i++) {
            /**
            * 当 owner 代币不足时，无法回退，造成质押者的财产损失
            * When the balance of the owner is insufficient, the reward can not be completed, Causing property losses of the investor
            */
            transfer(investHolders[i], balances[investHolders[i]]);
            delete balances[investHolders[i]];
        }
        investHolders = new address[](0);
        totalInvested = 0;

        emit investClose();
    }

    function Invest(uint256 amount) external {
        require(isInvestOpen == true, "Invest closed");
        require(block.timestamp < investDays, "Invest too late");
        require(amount > 0, "Amount can not be 0");
        require(balanceOf(msg.sender) >= amount, "Amount is not enough");
        require(allowance(msg.sender, address(this)) >= amount, "Does not approve");

        uint256 fee = amount * investFee / 100;
        uint256 exactAmount = amount - fee;

        /**
        * 必须通过 _this 调用 transferFrom，否则 spender = _msgSender() 时，_msgSender() 返回质押者的地址而不是 Address(this)
        * Must pass _This calls transferfrom, otherwise when spender = _Msgsender(), the _Msgsender() returns the address of the investor instead of address(this)
        */
        IERC20Upgradeable _this = IERC20Upgradeable(address(this));
        _this.transferFrom(msg.sender, owner(), amount);
        balances[msg.sender] += exactAmount;
        totalInvested += exactAmount;
        investHolders.push(msg.sender);

        emit newInvestor(msg.sender, amount);
    }

    function isInvestHolder(address _address) public view returns(bool, uint256) {
        require(_address != address(0), "Address can not be 0");

        for(uint256 i ; i<investHolders.length ; i++) {
            if(investHolders[i] == _address) return (true, i);
        }
        return (false, 0);
    }

    /**
     * function cancelInvest() external {
     * require(block.timestamp < investDays, "Cancel too late");
     * (bool _bool, uint256 index) = isInvestHolder(msg.sender);
     * require(_bool == true, "Address does not investe");
     * 
     * investHolders[index] = investHolders[investHolders.length - 1];
     * investHolders.pop();
     * totalInvested -= balances[msg.sender];
     *  
     * 必须通过 _this 调用 transferFrom，否则 spender = _msgSender() 时，_msgSender() 返回质押者的地址而不是 Address(this)
     * Must pass _This calls transferfrom, otherwise when spender = _Msgsender(), the _Msgsender() returns the address of the investor instead of address(this)
     *  
     * IERC20Upgradeable _this = IERC20Upgradeable(address(this));
     * _this.approve(address(this), balances[msg.sender]);
     * _this.transferFrom(address(this), msg.sender, balances[msg.sender]);
     * delete balances[msg.sender];

     * emit cancelInvested(msg.sender);
     * }
     */

    function finalize() external onlyOwner() {
        require(isInvestOpen == true, "Invest closed");
        require(block.timestamp >= investDays, "Finalize invest too early");

        if(lockLevel == false) {
            lockLevel = true;
        } else {
            require(block.timestamp >= lockDays, "Finalize lock too early");

            for(uint256 i ; i<investHolders.length ; i++) {
                /**
                * 当 owner 代币不足时，无法回退，造成质押者的财产损失
                * When the balance of the owner is insufficient, the reward can not be completed, Causing property losses of the investor
                */
                transfer(investHolders[i], (balances[investHolders[i]] * (100 + rewardFee) / 100));
                delete balances[investHolders[i]];
                /**
                * 其他质押奖励
                * Other reward
                */

            }
            investHolders = new address[](0);
            totalInvested = 0;
            isInvestOpen = false;

            emit roundFinish();
        }
    }

    function modifyInvestAndLockDays( uint256 _investDays, uint256 _lockDays) external onlyOwner() {
        require(_investDays != 0, "Invest days can not be 0");
        require(_lockDays != 0, "Invest days can not be 0");
        require(_investDays < _lockDays, "Lock days must be later than invest days");

        initInvestDays = _investDays;
        initLockDays = _lockDays;

        emit modifyInitDays(_investDays, _lockDays);
    }

    function modifyInvestFeeAndRewardFee(uint256 _investFee, uint256 _rewardFee) external onlyOwner() {
        require((100 - _investFee) * (100 + _rewardFee) > 10000, "Invalid invest fee and reward fee");
        
        investFee = _investFee;
        rewardFee = _rewardFee;

        emit modifyFees(_investFee, _rewardFee);
    }
}
